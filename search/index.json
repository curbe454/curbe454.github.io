[{"content":"nushell 踩坑记 9.26 听说 nushell 很好，我今天试了试，结果差点被劝退了。\n看了一眼官方文档，感觉不错，居然还支持函数式，就一边看文档一边想办法转移我在其他 shell 的配置。\n我首先就是使用我的 oh-my-posh. 这时候就踩坑了。我编写了一个这样的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 def set-theme [name] { let theme_dir = $\u0026#34;($env.SCOOP)/apps/oh-my-posh/current/themes\u0026#34; let theme_omp = $\u0026#34;($theme_dir)/($name).omp.json\u0026#34; let theme_nu = $\u0026#34;($theme_dir)/theme.nu\u0026#34; if not ($theme_nu | path exists) { touch $theme_nu } if ($theme_omp | path exists) { oh-my-posh init nu --config $\u0026#34;($theme_dir)/($name).omp.json\u0026#34; --print o\u0026gt; $theme_nu } source $theme_nu } 思路很简单，就是利用传进来的字符串决定 theme 样式。\n要是有懂 nushell 的就能一眼看出来，这里最重要的代码 source $theme_nu 是完全行不通的，因为这个代码是执行在函数的作用域里面而不是全局作用域。\n我找了 Deepseek 求证了一下，它还给我出一些\u0026quot;在 def 之后加上 --env\u0026quot;，或者把\u0026quot;source 改成 overlay use\u0026ldquo;这样的馊主意。这个 def --env 是在当期望函数可以修改环境变量 $env.* 的时候使用，而 overlay use 是模块化包装，这样也不会把这个作用域给突破。\n我想着这一点也不 shell-like，缺少这个功能，那就根本不是一个正宗的 shell. 我想着能否通过 alias 绕过，结果发现这样会形成 alias theme = set-theme $name; source $theme_file 这样的情况，这就要求 alias 也能输入参数。但是这是不符合 alias 语法的，除非我再引入一个新函数，但是这样还是不能绕过作用域。\n我放弃了，于是把 source 语句放在了 config nu 的文件里，死马当活马医，要是不行我直接删了。结果就成功了，这个 config 是使用全局作用域的，好吧，我承认你是个 shell\u0026hellip;\n以上我折腾了俩小时的成果。。。途中我真的被这个\u0026quot;不能 parse\u0026quot;的错误提示给整急眼了，开始厌恶这个要命的静态解析，我写过 bash 和 powershell, 我哪能遭这种罪，甚至觉得 python 和 C 语言的时候多自由啊，这种这不让做那不让做的能叫 shell 嘛。。。只能说折腾起来真是坑啊。\n9.27 不行了，我不玩了，我这就删除这个毒瘤。\n我有这样一个奇异的 powershell 脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # OCaml function opamact { (\u0026amp; opam env) -split \u0026#39;\\r?\\n\u0026#39; | ForEach-Object { Invoke-Expression $_ } } function ocaml_init_wrapper { param( [string]$CommandName, [string]$ExecutableName = $null ) if (-not $ExecutableName) { $ExecutableName = $CommandName } $functionDef = @\u0026#34; function global:$CommandName { if (-not `$env:OPAM_SWITCH_PREFIX) { opamact } \u0026amp; \u0026#34;$ExecutableName\u0026#34; @args } \u0026#34;@ Invoke-Expression $functionDef } ocaml_init_wrapper \u0026#34;ocaml\u0026#34; \u0026#34;ocaml.exe\u0026#34; ocaml_init_wrapper \u0026#34;ocamlc\u0026#34; \u0026#34;ocamlc.exe\u0026#34; ocaml_init_wrapper \u0026#34;ocamldoc\u0026#34; \u0026#34;ocamldoc.exe\u0026#34; ocaml_init_wrapper \u0026#34;ocamlrun\u0026#34; \u0026#34;ocamlrun.exe\u0026#34; ocaml_init_wrapper \u0026#34;ocamlopt\u0026#34; \u0026#34;ocamlopt.exe\u0026#34; ocaml_init_wrapper \u0026#34;dune\u0026#34; \u0026#34;dune.exe\u0026#34; ocaml_init_wrapper \u0026#34;utop\u0026#34; \u0026#34;utop.exe\u0026#34; 之所以要这么整，是因为假设直接 opam env 命令消耗的时间实在是有些长。本来我的电脑就不行，打开一个 powershell 对话就要大概 700 ms. 加上这个直接高达 1.2s, 这谁受得了；于是乎做了个按需加载。不止这个，我还有 conda 和 MSVC 环境呢，这些又应该怎么解决呢（当然这几个肯定要简单一些）。\n我尝试了两个小时企图复现这个逻辑，结果发现这个东西的限制实在是太让人难受，alias 根本绑定不了 source 命令，这对我的动态加载是致命的。我最后最接近的版本是这个：\n1 2 3 4 5 6 7 8 # OCaml const opam_env_file = $\u0026#34;($code)/.opam_env.nu\u0026#34; def get-opamenv [] { if not ($opam_env_file | path exists) { touch $opam_env_file } opam env --shell=powershell | lines | each {|e| str replace \u0026#34;$env:\u0026#34; \u0026#34;$env.\u0026#34;} o\u0026gt; $opam_env_file } alias opamact = get-opamenv; source $opam_env_file 是的，这样也未尝不可。每次使用了 opamact 或者 get-opamenv 之后记得再使用 source 命令就好。然后才能执行 ocaml.exe, ocamlc.exe 这些程序。。。一个命令只做一件事，十分符合 nushell 尊崇的 Unix 教义，对吧？ F**k, can you understand why I just do these in powershell? 这个 nushell 的这一部分设计的一点也不好，让 shell 失去了它应该做到的动态加载的部分，给它加上了一把名叫 parse 的枷锁。我难受极了，感觉像被喂了 s**t.\nscoop uninstall nu, 启动！\n","date":"2025-09-27T02:40:42+08:00","permalink":"https://curbe454.github.io/p/try-nushell-and-not-feel-good/","title":"Try nushell and not feel good"},{"content":"All asm codes are compiled in https://godbolt.org/, by x86-64 ocamlopt 5.2.0.\nlet declaration Let\u0026rsquo;s start from a simple example. A whole file is written with only two lines:\n1 2 3 let a = 10 let b = [1;2;3] Compiled:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 camlExample.data_begin: camlExample.code_begin: camlExample: .quad 1 .quad 1 camlExample.gc_roots: .quad camlExample .quad 0 camlExample.3: .quad 3 .quad camlExample.2 camlExample.2: .quad 5 .quad camlExample.1 camlExample.1: .quad 7 .quad 1 camlExample.entry: movl $21, %esi movq camlExample@GOTPCREL(%rip), %rdi movq %rsp, %rbx movq 64(%r14), %rsp call caml_initialize@PLT movq %rbx, %rsp movq camlExample.3@GOTPCREL(%rip), %rsi movq camlExample@GOTPCREL(%rip), %rdi addq $8, %rdi movq %rsp, %rbx movq 64(%r14), %rsp call caml_initialize@PLT movq %rbx, %rsp movl $1, %eax ret camlExample.code_end: camlExample.data_end: .quad 0 camlExample.frametable: .quad 0 The value of the list is stored in segment.\nThe immediate value $21 is the value of a 10, I guess that may bring some benefit for arithmetic (And 21 \u0026gt;\u0026gt; 1 == 10).\nThe 3 in camlExample.3 is the 1, and the 5 in camlExample.2 is the 2. I can see the linked list structure that there\u0026rsquo;s an address right after the integer data(and there\u0026rsquo;s a 1 as zero standing for the tail).\nAfter get the address of the variables, it calls the function caml_initialize, the 1st is caml_initialize(camlExample, 10) and the 2nd is caml_initialize(camlExample+8, camlExample.3). So I know the data in camlExample stores the pointer of the variables. The official doc also mentioned it.\nI also see that it mov a strange value %r14 + 64 to %rsp to take place of previous %rsp. This is not easy to explain. In short, OCaml compiler use Emulating Thread Local Storage tech in gcc to let the OCaml processes run as threads of C process, which causes the variable declaration caml_initialize should use the main thread process stack address %r14 + 0x40. It doesn\u0026rsquo;t matter and I can just ignore it(although I takes hours to make it up).\ncurry Source code 1 2 3 4 let sum_ints = List.fold_left (fun acc x -\u0026gt; acc + x) 0 let res = sum_ints [1;2;3] Assembly 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 camlExample.data_begin: camlExample.code_begin: camlExample.4: .quad caml_curry2 .quad 0x200000000000007 .quad camlExample.fun_342 camlExample: .quad 1 .quad 1 camlExample.gc_roots: .quad camlExample .quad 0 camlExample.fun_342: leaq -1(%rax,%rbx), %rax ret camlExample.fun_348: movq %rax, %rdi movq 24(%rbx), %rsi movq 16(%rbx), %rax movq %rsi, %rbx jmp camlStdlib__List.fold_left_380@PLT camlExample.3: .quad 3 .quad camlExample.2 camlExample.2: .quad 5 .quad camlExample.1 camlExample.1: .quad 7 .quad 1 camlExample.entry: leaq -320(%rsp), %r10 cmpq 40(%r14), %r10 jb .L103 ; goto .L103 when space is not enough .L104: movl $1, %eax movq camlExample.4@GOTPCREL(%rip), %rbx movq camlStdlib__List@GOTPCREL(%rip), %rdi movq 200(%rdi), %rdi subq $48, %r15 call caml_allocN@PLT .L105: leaq 8(%r15), %rsi ; heap + 8 movq $5367, -8(%rsi) ; strange metadata movq camlExample.fun_348@GOTPCREL(%rip), %rdx movq %rdx, (%rsi) movabsq $72057594037927941, %rdx movq %rdx, 8(%rsi) ; $72057594037927941 movq %rbx, 16(%rsi) ; camlExample.4 movq %rax, 24(%rsi) ; zero (%eax == 1, 1 \u0026gt;\u0026gt; 1 == 0) movq %rdi, 32(%rsi) ; List.fold_left movq camlExample@GOTPCREL(%rip), %rdi movq %rsp, %rbx movq 64(%r14), %rsp call caml_initialize@PLT movq %rbx, %rsp movq camlExample@GOTPCREL(%rip), %rax movq (%rax), %rax ; pointer of sum_ints expression movq camlExample.3@GOTPCREL(%rip), %rdi movq 24(%rax), %rbx ; zero movq 16(%rax), %rax ; camlExample.4 call camlStdlib__List.fold_left_380@PLT .L106: movq camlExample@GOTPCREL(%rip), %rdi addq $8, %rdi ; camlExample + 8, pointer of res movq %rax, %rsi ; value of res movq %rsp, %rbx movq 64(%r14), %rsp call caml_initialize@PLT ; caml_initialize(camlExample+8, %rsi) movq %rbx, %rsp movl $1, %eax ret .L103: push $33 call caml_call_realloc_stack@PLT popq %r10 jmp .L104 camlExample.code_end: camlExample.data_end: .quad 0 camlExample.frametable: .quad 2 .quad .L106 .word 9 .word 0 .long (.L107 - .) + 0 .quad .L105 .word 11 .word 1 .word 5 .byte 1 .byte 4 .long (.L108 - .) + 0 .L107: .long (.L110 - .) + 1 .long 1053016 .long (.L111 - .) + 0 .long 2107600 .L108: .long (.L110 - .) + 0 .long 1053016 .L109: .ascii \u0026#34;/app/example.ml\\0\u0026#34; .L111: .long (.L109 - .) + 0 .ascii \u0026#34;Example.res\\0\u0026#34; .L110: .long (.L109 - .) + 0 .ascii \u0026#34;Example.sum_ints\\0\u0026#34; Because the interger in OCaml is OCamlnum == realnum * 2 + 1, The leaq -1(%rax,%rbx), %rax in camlExample.fun_342 is doing a plus operation. It\u0026rsquo;s my (fun acc x -\u0026gt; acc + x).\nAt here the official doc said %r15 is used as a heap pointer in my case:\nOCaml on x86_64 architectures caches the location of the minor heap in the %r15 register since it's so frequently referenced in OCaml functions.\nIt\u0026rsquo;s amazing that there\u0026rsquo;s two ways to curry a function. The first is the camlExample.4, use a built-in function to curry my lambda function. Another is to build a sequence for a expression, and evaluate it.\n","date":"2025-06-02T04:21:25+08:00","permalink":"https://curbe454.github.io/p/ocaml_reverse_start/","title":"Ocaml_reverse_start"}]